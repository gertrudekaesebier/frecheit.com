<!DOCTYPE html>
<!-- Version: 1.0.0 - Update this number when deploying changes -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>frecheit.com</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #1f2128;
        }

        canvas {
            display: block;
        }

        #textInput {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            max-width: 500px;
            padding: 16px 20px;
            padding-bottom: max(16px, env(safe-area-inset-bottom) + 16px);
            background: transparent;
            border: 2px solid rgba(211, 255, 25, 0.3);
            border-radius: 12px;
            color: #d3ff19;
            font-size: 18px;
            font-family: Arial, sans-serif;
            text-align: center;
            outline: none;
            z-index: 100;
            box-sizing: border-box;
            touch-action: manipulation;
            appearance: none;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 15px rgba(211, 255, 25, 0.15);
        }

        #textInput:focus {
            border-color: rgba(211, 255, 25, 0.6);
            box-shadow: 0 0 25px rgba(211, 255, 25, 0.3);
        }

        #textInput::placeholder {
            color: rgba(211, 255, 25, 0.5);
        }

        @media (max-width: 768px) {
            #textInput {
                bottom: 16px;
                width: calc(100% - 32px);
                padding: 14px 16px;
                padding-bottom: max(14px, env(safe-area-inset-bottom) + 14px);
                font-size: 16px;
                border-radius: 10px;
            }
        }

        #controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-width: 100%;
            background: rgba(26, 29, 36, 0.6);
            border: none;
            border-bottom: 2px solid rgba(211, 255, 25, 0.3);
            border-radius: 0 0 20px 20px;
            padding: 12px;
            padding-top: 40px;
            backdrop-filter: blur(5px);
            z-index: 100;
            color: #d3ff19;
            font-family: Arial, sans-serif;
            font-size: 11px;
            transition: none;
            overflow-y: auto;
            max-height: 33vh;
            transform: translateY(calc(-100vh - 50vh));
        }

        #controlsHandle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 32px;
            background: rgba(26, 29, 36, 0.6);
            border: 2px solid rgba(211, 255, 25, 0.3);
            border-top: none;
            border-radius: 0 0 10px 10px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #controlsHandle:active {
            cursor: grabbing;
        }

        #controlsHandle::after {
            content: '';
            width: 30px;
            height: 3px;
            background: rgba(211, 255, 25, 0.5);
            border-radius: 2px;
        }

        #topDragArea {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            z-index: 101;
            cursor: grab;
            touch-action: none;
        }

        #topDragArea:active {
            cursor: grabbing;
        }

        .control-group {
            margin-bottom: 12px;
            background: rgba(26, 29, 36, 0.4);
            padding: 10px;
            border-radius: 8px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 10px;
        }

        .control-value {
            color: rgba(211, 255, 25, 0.7);
            font-weight: bold;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(211, 255, 25, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #d3ff19;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(211, 255, 25, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #d3ff19;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(211, 255, 25, 0.5);
        }

        @media (max-width: 768px) {
            #controls {
                padding: 10px;
                padding-top: 36px;
                font-size: 10px;
            }
            
            .control-label {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <input type="text" id="textInput" placeholder="Enter text..." />
    <div id="topDragArea"></div>
    <div id="controls">
        <div id="controlsHandle"></div>
        <div class="control-group">
            <div class="control-label">
                <span>Emissive Intensity</span>
                <span class="control-value" id="emissiveValue">0.2</span>
            </div>
            <input type="range" class="slider" id="emissiveSlider" min="0" max="2" step="0.1" value="0.2">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Bloom Strength</span>
                <span class="control-value" id="bloomStrengthValue">0.9</span>
            </div>
            <input type="range" class="slider" id="bloomStrengthSlider" min="0" max="3" step="0.1" value="0.9">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Bloom Radius</span>
                <span class="control-value" id="bloomRadiusValue">0.3</span>
            </div>
            <input type="range" class="slider" id="bloomRadiusSlider" min="0" max="2" step="0.1" value="0.3">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Bloom Threshold</span>
                <span class="control-value" id="bloomThresholdValue">0.05</span>
            </div>
            <input type="range" class="slider" id="bloomThresholdSlider" min="0" max="1" step="0.05" value="0.05">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Transmission</span>
                <span class="control-value" id="transmissionValue">0.00</span>
            </div>
            <input type="range" class="slider" id="transmissionSlider" min="0" max="1" step="0.05" value="0.00">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Opacity</span>
                <span class="control-value" id="opacityValue">0.55</span>
            </div>
            <input type="range" class="slider" id="opacitySlider" min="0.5" max="1" step="0.05" value="0.55">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Fog Near</span>
                <span class="control-value" id="fogNearValue">8</span>
            </div>
            <input type="range" class="slider" id="fogNearSlider" min="0" max="20" step="0.5" value="8">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Fog Far</span>
                <span class="control-value" id="fogFarValue">25</span>
            </div>
            <input type="range" class="slider" id="fogFarSlider" min="10" max="50" step="1" value="25">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Ambient Light</span>
                <span class="control-value" id="ambientValue">0.3</span>
            </div>
            <input type="range" class="slider" id="ambientSlider" min="0" max="1" step="0.05" value="0.3">
        </div>
        <div class="control-group">
            <div class="control-label">
                <span>Text Size Multiplier</span>
                <span class="control-value" id="textSizeMultiplierValue">1.45</span>
            </div>
            <input type="range" class="slider" id="textSizeMultiplierSlider" min="0.5" max="2.0" step="0.05" value="1.45">
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1f2128);  // Darker background
        // Atmospheric fog for cinematic falloff
        scene.fog = new THREE.Fog(0x1f2128, 8, 25);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 5;

        // Renderer with proper settings for physical materials
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        // Set pixel ratio for high-DPI displays (retina, etc.) to prevent pixelation
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2 for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Lighting setup for proper shading
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight1.position.set(5, 5, 5);
        directionalLight1.castShadow = true;
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xd3ff19, 0.6);
        directionalLight2.position.set(-5, -3, 2);
        scene.add(directionalLight2);

        // Milk glass material - more translucent with cinematic glow
        const textMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xd3ff19,
            metalness: 0.0,
            roughness: 0.6,
            transmission: 0.00,
            opacity: 0.55,
            transparent: true,
            thickness: 0.5,
            ior: 1.5,
            clearcoat: 0.1,
            clearcoatRoughness: 0.4,
            emissive: 0xd3ff19,
            emissiveIntensity: 0.15,  // Reduced for better readability
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: true
        });

        // Post-processing for subtle bloom/glow
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.75,  // Reduced bloom strength for better readability
            0.3,  // Bloom radius
            0.05  // Bloom threshold
        );
        composer.addPass(bloomPass);

        // Connect sliders to material and bloom values
        const emissiveSlider = document.getElementById('emissiveSlider');
        const emissiveValue = document.getElementById('emissiveValue');
        emissiveSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            textMaterial.emissiveIntensity = value;
            emissiveValue.textContent = value.toFixed(1);
        });

        const bloomStrengthSlider = document.getElementById('bloomStrengthSlider');
        const bloomStrengthValue = document.getElementById('bloomStrengthValue');
        bloomStrengthSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            bloomPass.strength = value;
            bloomStrengthValue.textContent = value.toFixed(1);
        });

        const bloomRadiusSlider = document.getElementById('bloomRadiusSlider');
        const bloomRadiusValue = document.getElementById('bloomRadiusValue');
        bloomRadiusSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            bloomPass.radius = value;
            bloomRadiusValue.textContent = value.toFixed(1);
        });

        const bloomThresholdSlider = document.getElementById('bloomThresholdSlider');
        const bloomThresholdValue = document.getElementById('bloomThresholdValue');
        bloomThresholdSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            bloomPass.threshold = value;
            bloomThresholdValue.textContent = value.toFixed(2);
        });

        const transmissionSlider = document.getElementById('transmissionSlider');
        const transmissionValue = document.getElementById('transmissionValue');
        transmissionSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            textMaterial.transmission = value;
            transmissionValue.textContent = value.toFixed(2);
        });

        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        opacitySlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            textMaterial.opacity = value;
            opacityValue.textContent = value.toFixed(2);
        });

        // Fog and ambient light controls
        const fogNearSlider = document.getElementById('fogNearSlider');
        const fogNearValue = document.getElementById('fogNearValue');
        fogNearSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            scene.fog.near = value;
            fogNearValue.textContent = value.toFixed(1);
        });

        const fogFarSlider = document.getElementById('fogFarSlider');
        const fogFarValue = document.getElementById('fogFarValue');
        fogFarSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            scene.fog.far = value;
            fogFarValue.textContent = value.toFixed(0);
        });

        const ambientSlider = document.getElementById('ambientSlider');
        const ambientValue = document.getElementById('ambientValue');
        ambientSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            ambientLight.intensity = value;
            ambientValue.textContent = value.toFixed(2);
        });

        // Text size multiplier
        let textSizeMultiplier = 1.45;
        const textSizeMultiplierSlider = document.getElementById('textSizeMultiplierSlider');
        const textSizeMultiplierValue = document.getElementById('textSizeMultiplierValue');
        textSizeMultiplierSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            textSizeMultiplier = value;
            textSizeMultiplierValue.textContent = value.toFixed(2);
            
            // Recalculate text size if text exists
            if (loadedFont && textMesh) {
                const input = document.getElementById('textInput');
                const currentText = input.value || initialText;
                createTextMesh(currentText);
            }
        });

        let textMesh = null;
        let loadedFont = null;

        // Function to calculate text size based on window dimensions
        function calculateTextSize(text) {
            // Always calculate size based on "frecheit.com" regardless of actual text
            const referenceText = "frecheit.com";
            
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const isMobile = windowWidth < 768;
            const cameraZ = 5;
            const cameraFOV = 75;
            
            // Account for input field at bottom and padding
            const availableHeight = windowHeight - (isMobile ? 100 : 80);
            const availableWidth = windowWidth - (isMobile ? 40 : 60);
            
            // Convert screen pixels to world units at camera distance
            // Visible width in world units = 2 * distance * tan(FOV/2)
            const fovRad = (cameraFOV * Math.PI) / 180;
            const aspect = windowWidth / windowHeight;
            const visibleWorldHeight = 2 * cameraZ * Math.tan(fovRad / 2);
            const visibleWorldWidth = visibleWorldHeight * aspect;
            
            // Convert available screen space to world units
            const worldWidth = (availableWidth / windowWidth) * visibleWorldWidth;
            const worldHeight = (availableHeight / windowHeight) * visibleWorldHeight;
            
            // Account for spaces - each letter gets a space after it
            const spacedCharCount = referenceText.length * 2 - 1; // letters + spaces
            
            // Estimate: each character with space takes approximately 0.7 * size units (more conservative)
            // We want: spacedCharCount * 0.7 * size <= worldWidth
            // So: size <= worldWidth / (spacedCharCount * 0.7)
            const widthBasedSize = (worldWidth / (spacedCharCount * 0.7)) * 0.85; // 0.85 safety margin (increased by ~30%)
            
            // Height constraint: text height should be less than available world height
            // Text height is roughly 1.0 * size (for most fonts)
            const heightBasedSize = worldHeight * 0.9; // 0.9 safety margin (increased)
            
            // Use the smaller of the two to ensure text fits both dimensions
            const calculatedSize = Math.min(widthBasedSize, heightBasedSize);
            
            // Apply text size multiplier
            const finalSize = calculatedSize * textSizeMultiplier;
            
            // Clamp between reasonable min/max values
            return Math.max(0.1, Math.min(0.65, finalSize));
        }

        // Function to create or update text mesh
        function createTextMesh(text) {
            if (!loadedFont || !text || text.trim() === '') {
                return;
            }

            // Remove existing text mesh
            if (textMesh) {
                scene.remove(textMesh);
                if (textMesh.geometry) {
                    textMesh.geometry.dispose();
                }
            }

            // Add space between each letter
            const spacedText = text.split('').join(' ');

            // Calculate text size based on window dimensions
            const textSize = calculateTextSize(text);

            // Create new text geometry
            const textGeometry = new TextGeometry(spacedText, {
                font: loadedFont,
                size: textSize,
                height: textSize * 0.8,  // Height proportional to size
                curveSegments: 16,
                bevelEnabled: true,
                bevelThickness: textSize * 0.1,  // Bevel proportional to size
                bevelSize: textSize * 0.08,
                bevelOffset: 0,
                bevelSegments: 8
            });

            textGeometry.center();
            textGeometry.computeVertexNormals();

            // Create new mesh
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.castShadow = true;
            textMesh.receiveShadow = true;
            textMesh.rotation.y = -Math.PI / 4;  // Start at -45 degrees
            scene.add(textMesh);
        }

        // Get initial text from URL query parameter (before font loads)
        const urlParams = new URLSearchParams(window.location.search);
        const initialTextFromUrl = urlParams.get('text');
        const initialText = initialTextFromUrl ? decodeURIComponent(initialTextFromUrl) : 'frecheit.com';
        
        // Load font and create initial text
        const loader = new FontLoader();
        loader.load(
            'https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',
            (font) => {
                loadedFont = font;
                // Use initialText from URL or default, but don't use input.value
                createTextMesh(initialText);
            }
        );

        // Connect input field to text update
        const textInput = document.getElementById('textInput');
        let updateTimeout = null;
        
        // Keep input field empty to encourage typing (even if URL has text)
        textInput.value = '';
        
        textInput.addEventListener('input', (e) => {
            clearTimeout(updateTimeout);
            // Debounce updates for better performance
            updateTimeout = setTimeout(() => {
                const newText = e.target.value || initialText;
                createTextMesh(newText);
                
                // Update URL query parameter without page reload
                const newUrl = new URL(window.location);
                if (e.target.value && e.target.value.trim() !== '') {
                    newUrl.searchParams.set('text', encodeURIComponent(e.target.value));
                } else {
                    newUrl.searchParams.delete('text');
                }
                window.history.pushState({}, '', newUrl);
            }, 300);
        });

        // Controls panel slide functionality
        const controls = document.getElementById('controls');
        const controlsHandle = document.getElementById('controlsHandle');
        const topDragArea = document.getElementById('topDragArea');
        let isDragging = false;
        let startY = 0;
        let startTranslate = 0;
        let lastDeltaY = 0;
        let dragStartedOutside = false;
        let dragStartedFromHandle = false;
        let hasDragged = false;

        function getPanelHeight() {
            // Get the natural height of the panel (when not transformed)
            // We know max-height is 33vh, so calculate directly from viewport
            // This is the maximum visible height the panel can have
            return (33 / 100) * window.innerHeight;
        }

        function isPointInsidePanel(x, y) {
            const rect = controls.getBoundingClientRect();
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }

        function updatePanelTransform(y) {
            const panelHeight = getPanelHeight();
            // Add LARGE extra offset to ensure panel is completely hidden (account for borders, padding, rounding, any edge cases)
            // Use at least 100px or 50% of viewport height, whichever is larger
            const extraOffset = Math.max(100, window.innerHeight * 0.5);
            // Allow dragging from -100% (fully hidden) to 0 (fully visible)
            const translateY = Math.max(-panelHeight - extraOffset, Math.min(0, y));
            controls.style.transform = `translateY(${translateY}px)`;
            controls.style.transition = isDragging ? 'none' : 'transform 0.3s ease-out';
        }

        function getCurrentTranslate() {
            // Always check inline style first (what we set via JavaScript)
            const transform = controls.style.transform;
            const panelHeight = getPanelHeight();
            
            if (!transform || transform === 'none' || transform === '') {
                return -panelHeight;
            }
            
            const match = transform.match(/translateY\(([^)]+)\)/);
            if (!match) return -panelHeight;
            
            const value = match[1].trim();
            // Handle pixel values (what we always set)
            const pixelValue = parseFloat(value);
            if (!isNaN(pixelValue)) {
                return pixelValue;
            }
            
            // Fallback for percentage (shouldn't happen, but just in case)
            if (value.includes('%')) {
                const percent = parseFloat(value);
                return (percent / 100) * panelHeight;
            }
            
            return -panelHeight;
        }

        function handleStart(e) {
            // Don't start drag if clicking on interactive elements
            const target = e.target;
            if (target.closest('input') || 
                target.closest('button') || 
                target.closest('.slider') || 
                target.closest('.control-group') ||
                target.closest('label') ||
                target.tagName === 'INPUT' ||
                target.tagName === 'BUTTON' ||
                target.tagName === 'LABEL') {
                return; // Don't start drag
            }
            
            // Check if drag started from handle or topDragArea
            dragStartedFromHandle = (target === controlsHandle || target === topDragArea || 
                                     target.closest('#controlsHandle') || target.closest('#topDragArea'));
            
            const startX = e.touches ? e.touches[0].clientX : e.clientX;
            const startYPos = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Check if drag started outside the panel
            dragStartedOutside = !isPointInsidePanel(startX, startYPos);
            
            isDragging = true;
            startY = startYPos;
            startTranslate = getCurrentTranslate();
            lastDeltaY = 0; // Reset drag direction
            hasDragged = false; // Reset drag flag
            controls.style.transition = 'none';
        }

        function handleMove(e) {
            if (!isDragging) return;
            
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const deltaY = clientY - startY;
            
            // Mark as dragged if movement is significant
            if (Math.abs(deltaY) > 5) {
                hasDragged = true;
            }
            
            // Only prevent default if drag started outside panel or from handle (we're dragging the panel)
            // If drag started inside panel content, allow normal scrolling
            if (dragStartedOutside || dragStartedFromHandle) {
                e.preventDefault();
            }
            
            lastDeltaY = deltaY; // Track drag direction
            
            // Update panel transform if drag started outside or from handle
            if (dragStartedOutside || dragStartedFromHandle) {
                updatePanelTransform(startTranslate + deltaY);
            }
        }

        function handleEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            const panelHeight = getPanelHeight();
            const currentTranslate = getCurrentTranslate();
            
            // If drag started from handle, use normal open/close logic
            if (dragStartedFromHandle) {
                // If it was just a tap (no drag), toggle close
                if (!hasDragged) {
                    // Just a tap - close if open, open if closed
                    if (currentTranslate > -panelHeight + 10) {
                        updatePanelTransform(-panelHeight);
                    } else {
                        updatePanelTransform(0);
                    }
                } else if (lastDeltaY < -20) {
                    // Dragged up - close it
                    updatePanelTransform(-panelHeight);
                } else if (lastDeltaY > 20) {
                    // Dragged down - open it
                    updatePanelTransform(0);
                } else {
                    // Small movement - use position
                    if (currentTranslate > -panelHeight * 0.8) {
                        updatePanelTransform(0);
                    } else {
                        updatePanelTransform(-panelHeight);
                    }
                }
                return;
            }
            
            // For drags starting outside panel: only close if drag started OUTSIDE, ended INSIDE, and was dragged UP
            const endX = e && (e.changedTouches ? e.changedTouches[0].clientX : e.clientX);
            const endY = e && (e.changedTouches ? e.changedTouches[0].clientY : e.clientY);
            const dragEndedInside = endX !== undefined && endY !== undefined && isPointInsidePanel(endX, endY);
            
            if (dragStartedOutside && dragEndedInside && lastDeltaY < -20) {
                // Close the panel (started outside, ended inside, dragged up)
                updatePanelTransform(-panelHeight);
            } else if (lastDeltaY > 20) {
                // Dragging down - open it
                updatePanelTransform(0);
            } else {
                // Small movement - use position-based logic
                if (currentTranslate > -panelHeight * 0.8) {
                    updatePanelTransform(0); // Fully open
                } else {
                    updatePanelTransform(-panelHeight); // Fully hidden
                }
            }
        }

        // Touch events
        controlsHandle.addEventListener('touchstart', handleStart, { passive: false });
        topDragArea.addEventListener('touchstart', handleStart, { passive: false });
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd);

        // Mouse events - handle and top drag area
        controlsHandle.addEventListener('mousedown', handleStart);
        topDragArea.addEventListener('mousedown', handleStart);
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);
        
        // Click handler to close panel when handle is clicked (without dragging)
        controlsHandle.addEventListener('click', (e) => {
            // Prevent click if there was a drag
            if (hasDragged) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            // Close the panel
            const panelHeight = getPanelHeight();
            const currentTranslate = getCurrentTranslate();
            if (currentTranslate > -panelHeight + 10) {
                updatePanelTransform(-panelHeight);
            }
        });
        
        // Touch click handler - check in handleEnd instead
        // We'll handle it in handleEnd by checking if it was just a tap
        
        // Also allow dragging from outside the panel (for closing)
        // Only start if clicking outside the panel and panel is visible
        document.addEventListener('mousedown', (e) => {
            const target = e.target;
            // Don't interfere if clicking on handle or topDragArea (already handled)
            if (target === controlsHandle || target === topDragArea || 
                target.closest('#controlsHandle') || target.closest('#topDragArea')) {
                return;
            }
            
            // Check if panel is visible (not completely hidden)
            const currentTranslate = getCurrentTranslate();
            const panelHeight = getPanelHeight();
            const isPanelVisible = currentTranslate > -panelHeight + 10; // At least 10px visible
            
            if (!isPanelVisible) {
                return; // Panel is hidden, don't start drag
            }
            
            // Don't start if clicking inside panel (let normal scrolling work)
            const rect = controls.getBoundingClientRect();
            const clickY = e.clientY;
            if (rect.top >= 0 && clickY >= rect.top && clickY <= rect.bottom) {
                return; // Inside panel, don't interfere
            }
            // Start drag from outside
            handleStart(e);
        });
        
        document.addEventListener('touchstart', (e) => {
            const target = e.target;
            // Don't interfere if touching handle or topDragArea
            if (target === controlsHandle || target === topDragArea || 
                target.closest('#controlsHandle') || target.closest('#topDragArea')) {
                return;
            }
            
            // Check if panel is visible
            const currentTranslate = getCurrentTranslate();
            const panelHeight = getPanelHeight();
            const isPanelVisible = currentTranslate > -panelHeight + 10;
            
            if (!isPanelVisible) {
                return; // Panel is hidden, don't start drag
            }
            
            // Don't start if touching inside panel
            const rect = controls.getBoundingClientRect();
            const touchY = e.touches[0].clientY;
            if (rect.top >= 0 && touchY >= rect.top && touchY <= rect.bottom) {
                return; // Inside panel, don't interfere
            }
            // Start drag from outside
            handleStart(e);
        }, { passive: false });

        // Initial position (fully hidden) - wait for layout
        setTimeout(() => {
            const panelHeight = getPanelHeight();
            // Use at least 100px or 50% of viewport height, whichever is larger
            const extraOffset = Math.max(100, window.innerHeight * 0.5);
            // Set position without transition to prevent animation on load
            controls.style.transition = 'none';
            controls.style.transform = `translateY(${-panelHeight - extraOffset}px)`;
            // Enable transition after positioning is set
            setTimeout(() => {
                controls.style.transition = 'transform 0.3s ease-out';
            }, 10);
        }, 100);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (textMesh) {
                textMesh.rotation.y += 0.002;  // Slower rotation for better viewing
            }

            composer.render();
        }

        animate();

        // Handle window resize
        let resizeTimeout = null;
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.setSize(window.innerWidth, window.innerHeight);
            
            // Debounce text recalculation
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Recalculate text size and recreate mesh if text exists
                if (loadedFont) {
                    const input = document.getElementById('textInput');
                    const currentText = input.value || initialText;
                    createTextMesh(currentText);
                }
            }, 100);
        });
    </script>
</body>
</html>